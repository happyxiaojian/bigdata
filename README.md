# BIGDATA
**the proof of work of the bigdata learning**

昨天晚上弄环境弄到差不多2点多钟，最后解决的时候发现是非常愚蠢的错误。在启动zookeeper 的时候在master上 ssh 到slave1 然后当成是master主机，不断的去修改 myid ，同时也在slave1上修改myid, master的id 是1， slave1的id 是3，然后不断的来回的修改，还以为有什么进程在修改这个数据；另外，应该是master 和slave 的同时开启后，查看 zkServer.sh status 才不会报错。这个愚蠢的错误花了我大概4个小时；还发现一个问题是，以前为了求快，在解决问题的过程直接把解决问题的网页的链接保存了下来，但是解决问题的逻辑却忘记了。给自己的解决方案是，记录下自己的问题和解决问题的过程。这样在问题下次出现的时候就可以有依据可以查询。现在的情况是，slave1 和 slave2 在安装zkpython的时候要重新开始。本来在master上已经安装好了。

在linux运行环境上花的时间过多。



### #2019年3月28日 10:41:30

人在学习新的东西的时候内心都是很抵触的，一定要意识到这一点，并与之对抗，慢慢的将这种不好的感觉用解决之后的快感代替。

不管是只是还是工具，只会越用越熟练。

现在很多时间都浪费在环境的问题上，运行程序的时候，环境经常出现问题，排错的过程是很花时间的。不知道怎么解决，花的时间长，很让人沮丧。

昨天把 windows 下的 java 环境搭建起来，开始学习熟悉java和python的，目标是：

1. 可以看懂别人的程序
2. 可以手写常见的数据结构

现在在复习 HDFS ,不断的去理解概念 ，如果理解不了就死记下来。



### #2019年3月27日 09:44:39

今天看的一句比较有感觉的话是：所谓的成熟，有一个标志是喜欢的依旧喜欢但可以不拥有，害怕的依然害怕但可以去面对。

大数据学习的进度报告：昨天跟张盼聊天聊得忘了时间，几乎没怎么推进。昨天开始看python相关的东西了。在学习的过程中发现又一个问题是，以前的预习的东西有的缺少实践的环节。现在的策略是直接看正式课的内容，理论先过一遍，不纠结，然后实践，最后反过来验证理论，理解。

通过学习数据结构和算法去学习语言。数据结构和算法是通用的。

以后再每天的日志中加入每天新学到的概念的列表：

今天所学：

HBase 的列式存储就是根据 **CF** 分开存储（每个 **CF** 对应一个 **Store**）

**HBase** \  **行键RowKey**  \ **ColumnFamily**列族 \ 列成员**columnQualifier**    

时间戳**TimeStamp**  \  单元格**Cell**  \ 区域**Region** \ 



### #2019年3月26日 09:11:33

昨天通过 **PDF** 文档学习了**storm** 和 **zookeeper** , 学习的效果不尽人意，速度太慢，东西太多了看的多，马上就忘了。今天想到的是，可以多个文档一起比较起来看；另一个想到的学习的方式是，先把理论快速的过一遍，不对自己有过高的要求，不急于求成，然后马上进行理论的实践，通过实践再回过头去好好研究理论，这样应该可以避免空洞的看理论速度慢的问题。



#### #2019年3月25日 09:06:30

昨天学习发现一个问题，学习的进度太慢了，以前一直喜欢看视频学习，分析了下那些内容比较简单的
东西很好理解；但是现在学习的东西很多都是非常复杂的，不容易理解，需要常常去复习，这
个时候视频就显得很鸡肋，还是文档容易复习，而且现在要慢慢的适应文档的自学方式.现在给每天的任
务是早上早读的方式去读文档。



#### #2019年3月24日 22:00:33

看了9个小时的电视剧，19版的《倚天屠龙记》+ 《都挺好》
没有学习大数据，心情比较崩溃😫



#### #2019-03-22 14:16:32

the second time edit README.MD



#### #2019-03-24 10:41:01

今天从9：30过来，到现在已经差不多学习一个小时，**HDFS**

**hadoop2.0** 的主要思想是**JobTracker**两个主要的功能分分离成单独的组件，这两个功
能是资源管理和任务调度/监控

新的资源管理器全局管理所有应用程序计算资源的分配

**ApplicationMaster**负责相应的调度和协调

**ResourceManager**和每一台机器的阶段管理服务器能够管理用户在哪台机器上的进程
并能对计算进行组织。

**NodeManager**是每一台机器框架的代理，是执行应用程序的容器，监控应用程序的资
源使用情况（CPU 内存 磁盘 网络）并且向调度器汇报。

每一个应用的**ApplicationMaster**的职责有：向调度器索要适当的资源容器，运行任务，
跟踪应用程序的状态和监控他们的进程，处理任务的失败原因

客户端不变，其调用API及接口大部分保持兼容，这也是为了开发使用者透明化，
对原码不必做大的改变，但是原框架的**JobTracker**和**TaskTracker**不见了，取而代之的
是ResourceManager AppliactionMaster NodeManager三个部分。

ResourceManager是一个中心的服务，它做的事情是调度、启动每一个Job所属的
ApplicationMaster、另外监控ApplicationMaster的存在情况。Job里面所在的task的监
控，重启等内容不见了，这就是ApplicationMaster存在的原因。ResourceManager负
责作业与资源的调度，接收JobSubmitter提交的作业，按照作业的上下文(context)信
息，以及从NodeManager收集来的状态信息，启动调度过程，分配一个Container作
为Application Master

 *NodeManager 功能比较专一，就是负责Container状态的维护，并向RM保持心跳。

ApplicationMaster负责一个Job生命周期内的所有工作，类似老的框架中JobTracker,
但注意每一个Job(不是每一种)都有一个ApplicationMaster,他可以运行在ResourceManager
以外的机器上.







